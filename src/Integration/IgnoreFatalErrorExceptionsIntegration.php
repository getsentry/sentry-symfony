<?php

declare(strict_types=1);

namespace Sentry\SentryBundle\Integration;

use Sentry\Event;
use Sentry\ExceptionDataBag;
use Sentry\Integration\IntegrationInterface;
use Sentry\State\Scope;
use Symfony\Component\ErrorHandler\Error\FatalError;

/**
 * This integration skips the current {@see Event} if it is a {@see FatalError}
 * generated by Symfony that wraps an unhandled exception
 * (which should be already captured by Sentry).
 */
final class IgnoreFatalErrorExceptionsIntegration implements IntegrationInterface
{
    /**
     * @var ExceptionDataBag|null
     */
    private static $previousExceptionDataBag = null;

    public function setupOnce(): void
    {
        Scope::addGlobalEventProcessor(static function (Event $event): ?Event {
            $exceptionDataBag = $event->getExceptions()[0] ?? null;

            if (
                $exceptionDataBag instanceof ExceptionDataBag
                && $exceptionDataBag->getType() === self::$previousExceptionDataBag->getType()
                && $exceptionDataBag->getValue() === self::$previousExceptionDataBag->getValue()
            ) {
                return null;
            }

            return $event;
        });
    }
}
